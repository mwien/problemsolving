import java.util.Scanner;
import java.util.ArrayList;

public class Adjoin {

    public static void fDFS(Vertex u, LinkedList<Integer> sorting) {
	//compare with TS
	u.vis = true;
	for(Vertex v : u.out)
	    if(!v.vis)
		fDFS(v, sorting);
	sorting.addFirst(u.id);
	return sorting;
    }
    
    
    public static void sDFS(Vertex u, int cnt) {
	//basic DFS, all visited vertices get cnt
	u.vis = true;
	u.comp = cnt;
	for(Vertex v : u.in)
	    if(!v.vis)
		sDFS(v, cnt);
    }
    
    public static void doubleDFS(Vertex[] G) {
	//first calc a topological sort by first DFS
	LinkedList<Integer> sorting = new LinkedList<Integer>();
	for(int i = 0; i < G.length; i++)
	    if(!G[i].vis)
		fDFS(G[i], sorting);
	for(int i = 0; i < G.length; i++)
	    G[i].vis = false;
	//then go through the sort and do another DFS on G^T
	//each tree is a component and gets a unique number
	int cnt = 0;
	for(int i : sorting)
	    if(!G[i].vis)
		sDFS(G[i], cnt++);
    }
    
    
    public static void main(String[] args) {
	Scanner s = new Scanner(System.in);
	int c = s.nextInt();
	int l = s.nextInt();
	Vertex[] G = new Vertex[c];
	for(int i = 0; i < c; i++) {
	    G[i] = new Vertex(i);
	}
	for(int i = 0; i < l; i++) {
	    int a = s.nextInt();	 
	    int b = s.nextInt();
	    G[a].add(G[b]);
	    G[b].add(G[a]);
	}
	doubleDFS(G);
	
    }

}

class Vertex {

    int id;
    boolean vis = false;
    int comp = -1;

    ArrayList<Vertex> adj = new ArrayList<Vertex>();
    public Vertex(int id) {
	this.id = id;
    }
}
