#include<iostream>
#include<queue>
#include<algorithm>
#include<unordered_map>
#include<string>
#include<iomanip>

using namespace std;

struct pairhash {
public:
  template <typename T, typename U>
  std::size_t operator()(const std::pair<T, U> &x) const
  {
    return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);
  }
};

unordered_map<pair<int, int>, double, pairhash> T; 
string a;
int n, k;

inline int cbs(int pr, int i)
{
    return (pr & ((1 << i) -1)) + ((pr & (((1 << n) - 1) - ((1 << (i+1))-1))) >> 1);
}

double rec(pair<int, int> b)
{
    if(T.find(b) != T.end()) return T[b];
    if(b.second == k-1) {
	double sum = 0;
	int l = n - b.second;
	for(int i = 0; i < l/2; ++i) {
	    if((b.first & (1 << i)) || (b.first & (1 << (l - i- 1)))) sum += 2;
	}
	if(l % 2 == 1 && (b.first & (1 << l/2))) ++sum;
	double res = sum / l;
	T[b] = res;
	return res;
    }
    double ev = 0;
    int l = n - b.second;
    for(int i = 0; i < l / 2; ++i) {
	int f = 0, s = 0;
	int fv = 0, sv = 0;
	if(b.first & (1 << i)) ++fv;
	if(b.first & (1 << (l - i - 1))) ++sv; 
	//create bs
	f = cbs(b.first, i);
	s = cbs(b.first, l -i - 1);
	ev += 2 * max(rec({f, b.second+1}) + fv, rec({s, b.second+1}) + sv);
    }
    if(l % 2 == 1) {
	int f = 0;
	int fv = 0;
	if(b.first & (1 << l/2)) ++fv;
	// create bs
	f = cbs(b.first, l/2);
	ev += rec({f, b.second+1}) + fv;
    }
    double res = ev / l;
    T[b] = res;
    return res;
}

int main()
{
    T.reserve(10000000);
    cin >> n >> k;
    cin >> a;
    int st = 0;
    for(int i = 0; i < n; ++i) {
	if(a[i] == 'W') st += (1 << i);
    }
    cout << fixed << setprecision(10) << rec({st, 0}) << endl;
}
